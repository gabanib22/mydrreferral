name: Deploy MyDrReferral - Optimized

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-south-1

jobs:
  # Deploy Frontend to S3
  deploy-frontend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: Frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd Frontend
          npm ci

      - name: Build React app
        run: |
          cd Frontend
          npm run build
        env:
          NEXT_PUBLIC_API_URL: http://3.110.30.11

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          echo "Deploying frontend to S3 bucket: ${{ secrets.S3_BUCKET_NAME }}"
          aws s3 sync Frontend/out/ s3://${{ secrets.S3_BUCKET_NAME }} --delete
          aws s3 cp Frontend/out/index.html s3://${{ secrets.S3_BUCKET_NAME }}/index.html

  # Deploy API to EC2
  deploy-api:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: |
          cd Api
          dotnet restore --no-cache

      - name: Build API
        run: |
          cd Api
          dotnet build MyDrReferral.Api/MyDrReferral.Api.csproj --configuration Release --no-restore

      - name: Publish API
        run: |
          cd Api
          dotnet publish MyDrReferral.Api/MyDrReferral.Api.csproj --configuration Release --output ./publish --no-build

      - name: Create deployment package
        run: |
          cd Api
          tar -czf mydrreferral-api.tar.gz -C publish .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Copy API to EC2
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "Api/mydrreferral-api.tar.gz"
          target: "/var/www/mydrreferral/Api/"

      - name: Extract and start API
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 5m
          command_timeout: 5m
          script: |
            echo "üîß Starting API deployment..."
            cd /var/www/mydrreferral/Api/
            
            # Extract if tar.gz exists (SCP might have extracted already)
            if [ -f mydrreferral-api.tar.gz ]; then
              echo "Extracting tar.gz..."
              tar -xzf mydrreferral-api.tar.gz
              rm mydrreferral-api.tar.gz
            fi
            
            # Find the DLL location
            if [ -f MyDrReferral.Api.dll ]; then
              echo "‚úÖ Found MyDrReferral.Api.dll in current directory"
              API_DIR=$(pwd)
            elif [ -f Api/MyDrReferral.Api.dll ]; then
              echo "‚úÖ Found MyDrReferral.Api.dll in Api/ subdirectory"
              cd Api/
              API_DIR=$(pwd)
            else
              echo "‚ùå Cannot find MyDrReferral.Api.dll"
              find . -name "MyDrReferral.Api.dll" -type f
              exit 1
            fi
            
            # Install .NET if not found
            if ! command -v dotnet &> /dev/null; then
              echo "Installing .NET 8..."
              curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 8.0
              export DOTNET_ROOT=$HOME/.dotnet
              export PATH=$PATH:$HOME/.dotnet
            fi
            
            # Stop any running API processes first (before configuring Nginx)
            echo "Stopping existing API processes..."
            sudo systemctl stop mydrreferral-api.service || true
            sudo pkill -f "dotnet.*MyDrReferral.Api.dll" || true
            
            # Kill any remaining processes on port 5000
            PORT_PID=$(sudo netstat -tlnp 2>/dev/null | grep ':5000 ' | awk '{print $7}' | cut -d'/' -f1 | head -1 || echo "")
            if [ -n "$PORT_PID" ]; then
              echo "Killing process $PORT_PID on port 5000"
              sudo kill -9 $PORT_PID 2>/dev/null || true
            fi
            sleep 1
            
            # Only install/configure Nginx if needed (skip if already running)
            if systemctl is-active --quiet nginx 2>/dev/null; then
              echo "Nginx is already running"
            else
              if ! command -v nginx &> /dev/null; then
                echo "Installing Nginx..."
                sudo amazon-linux-extras install -y nginx1 > /dev/null 2>&1
                sudo systemctl enable nginx
              fi
              
              # Configure Nginx
              sudo tee /etc/nginx/conf.d/mydrreferral.conf > /dev/null <<'EOF'
server {
    listen 80;
    server_name _;
    
    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
EOF
            fi
            
            # Restart Nginx
            sudo systemctl restart nginx || true
            
            # Start API
            cd "$API_DIR"
            echo "Starting API from: $(pwd)"
            export ASPNETCORE_ENVIRONMENT=Production
            export ASPNETCORE_URLS=http://+:5000
            export ConnectionStrings__DefaultConnection="Host=10.0.1.150;Port=5432;Database=postgres;Username=postgres;Password=MyDrReferral123;"
            
            # Start API in background
            nohup dotnet MyDrReferral.Api.dll > /var/log/mydrreferral-api.log 2>&1 &
            API_PID=$!
            echo "API started with PID: $API_PID"
            
            # Wait a bit and check if it's still running
            sleep 3
            if ps -p $API_PID > /dev/null; then
              echo "‚úÖ API is running"
            else
              echo "‚ùå API process died. Checking logs:"
              tail -50 /var/log/mydrreferral-api.log
              exit 1
            fi

  # Health Check
  health-check:
    runs-on: ubuntu-latest
    needs: [deploy-api]
    steps:
      - name: Wait and test API
        run: |
          sleep 15
          echo "Testing API health..."
          for i in {1..5}; do
            if curl -f http://${{ secrets.EC2_HOST }}/api/healthcheck/success; then
              echo "‚úÖ API is healthy"
              break
            fi
            echo "Attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done
          
          echo ""
          echo "========================================="
          echo "Testing DateTime endpoint..."
          echo "========================================="
          
          echo "Trying GET first..."
          GET_RESPONSE=$(curl -s http://${{ secrets.EC2_HOST }}/api/healthcheck/test || echo "ERROR")
          echo "GET Response: $GET_RESPONSE"
          
          for i in {1..3}; do
            echo ""
            echo "Attempt $i: Calling test DateTime endpoint (POST)..."
            RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST http://${{ secrets.EC2_HOST }}/api/healthcheck/test 2>&1 || echo "HTTP_STATUS:000")
            HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS" | cut -d: -f2 || echo "000")
            BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS/d' | head -100)
            
            echo "Response Status: $HTTP_STATUS"
            echo "Response Body:"
            echo "$BODY"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ DateTime test PASSED"
              exit 0
            elif [ "$HTTP_STATUS" = "500" ]; then
              echo "‚ùå DateTime test FAILED with 500 error - this shows the DateTime issue!"
              echo "Full error details:"
              echo "$BODY"
              exit 1
            else
              if [ "$i" -lt 3 ]; then
                echo "Attempt $i failed (Status: $HTTP_STATUS), retrying in 3 seconds..."
                sleep 3
              fi
            fi
          done
          
          echo "‚ùå Could not reach endpoint (404). Checking if route exists..."
          curl -v http://${{ secrets.EC2_HOST }}/api/healthcheck/test 2>&1 | head -30
          
          echo "‚ùå DateTime test failed after 3 attempts"
          exit 1

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-api, health-check]
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy-frontend.result }}" == "success" ] && [ "${{ needs.deploy-api.result }}" == "success" ] && [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
            echo "Frontend: http://${{ secrets.S3_BUCKET_NAME }}.s3-website.ap-south-1.amazonaws.com"
            echo "API: http://${{ secrets.EC2_HOST }}"
          else
            echo "‚ùå Deployment failed!"
            echo "Frontend: ${{ needs.deploy-frontend.result }}"
            echo "API: ${{ needs.deploy-api.result }}"
            echo "Health: ${{ needs.health-check.result }}"
            exit 1
          fi