name: Deploy MyDrReferral - Optimized

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-south-1

jobs:
  # Deploy Frontend to S3
  deploy-frontend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: Frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd Frontend
          npm ci

      - name: Build React app
        run: |
          cd Frontend
          npm run build
        env:
          NEXT_PUBLIC_API_URL: http://3.110.30.11

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          echo "Deploying frontend to S3 bucket: ${{ secrets.S3_BUCKET_NAME }}"
          aws s3 sync Frontend/out/ s3://${{ secrets.S3_BUCKET_NAME }} --delete
          aws s3 cp Frontend/out/index.html s3://${{ secrets.S3_BUCKET_NAME }}/index.html

  # Deploy API to EC2
  deploy-api:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: |
          cd Api
          dotnet restore --no-cache

      - name: Build API
        run: |
          cd Api
          dotnet build MyDrReferral.Api/MyDrReferral.Api.csproj --configuration Release --no-restore

      - name: Publish API
        run: |
          cd Api
          dotnet publish MyDrReferral.Api/MyDrReferral.Api.csproj --configuration Release --output ./publish --no-build

      - name: Create deployment package
        run: |
          cd Api
          tar -czf mydrreferral-api.tar.gz -C publish .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Prepare remote target directory
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            sudo mkdir -p /var/www/mydrreferral/Api
            sudo chown -R ec2-user:ec2-user /var/www/mydrreferral/Api
            # Remove any stray directory with the archive name
            if [ -d /var/www/mydrreferral/Api/mydrreferral-api.tar.gz ]; then
              rm -rf /var/www/mydrreferral/Api/mydrreferral-api.tar.gz
            fi
            ls -la /var/www/mydrreferral/Api || true

      - name: Copy API to EC2
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "Api/mydrreferral-api.tar.gz"
          target: "~/"
          overwrite: true

      - name: Move and verify archive on EC2
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "Checking ~/ for uploaded archive..."
            ls -la ~ | sed -n '1,50p'
            echo "Checking ~/Api as well..."
            ls -la ~/Api 2>/dev/null | sed -n '1,50p' || true
            
            # If a directory named like the file exists, try to find the inner tar
            if [ -d ~/mydrreferral-api.tar.gz ]; then
              INNER=$(find ~/mydrreferral-api.tar.gz -type f -name "*.tar.gz" | head -1)
              if [ -n "$INNER" ]; then
                mv "$INNER" ~/mydrreferral-api.tar.gz
                rm -rf ~/mydrreferral-api.tar.gz/* || true
                rmdir ~/mydrreferral-api.tar.gz || true
              fi
            fi
            
            # If not found yet, search under home (handles ~/Api/mydrreferral-api.tar.gz cases)
            if [ ! -f ~/mydrreferral-api.tar.gz ]; then
              FOUND=$(find ~ -maxdepth 3 -type f -name "mydrreferral-api.tar.gz" | head -1)
              if [ -z "$FOUND" ]; then
                FOUND=$(find ~ -maxdepth 3 -type f -name "*.tar.gz" | head -1)
              fi
              if [ -n "$FOUND" ]; then
                echo "Found archive at: $FOUND"
                mv -f "$FOUND" ~/mydrreferral-api.tar.gz
              fi
            fi
            
            if [ -f ~/mydrreferral-api.tar.gz ]; then
              echo "Moving archive into /var/www/mydrreferral/Api..."
              mv -f ~/mydrreferral-api.tar.gz /var/www/mydrreferral/Api/mydrreferral-api.tar.gz
            else
              echo "‚ùå Could not find archive under home"
            fi
            
            echo "Verifying archive presence and checksum in target..."
            ls -la /var/www/mydrreferral/Api | sed -n '1,80p'
            sha256sum /var/www/mydrreferral/Api/mydrreferral-api.tar.gz || true

      - name: Extract and start API
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 5m
          command_timeout: 5m
          script: |
            set -e
            echo "üîß Deploying API via systemd..."
            BASE_DIR=/var/www/mydrreferral/Api
            STAGE_DIR="$BASE_DIR/stage"
            CURR_DIR="$BASE_DIR/current"
            UNIT_FILE=/etc/systemd/system/mydrreferral-api.service
            LOG_FILE=/tmp/mydrreferral-api.log

            sudo mkdir -p "$BASE_DIR" "$STAGE_DIR"
            cd "$BASE_DIR"

            # Normalize in case copy created a directory named like the file
            if [ -d mydrreferral-api.tar.gz ]; then
              INNER=$(find mydrreferral-api.tar.gz -type f -name "*.tar.gz" | head -1)
              if [ -n "$INNER" ]; then
                mv "$INNER" mydrreferral-api.tar.gz
                rm -rf mydrreferral-api.tar.gz/* || true
                rmdir mydrreferral-api.tar.gz || true
              fi
            fi

            # Ensure tar is present (SCP step sets overwrite: true)
            if [ ! -f mydrreferral-api.tar.gz ]; then
              echo "‚ùå Archive missing: $BASE_DIR/mydrreferral-api.tar.gz"
              ls -la "$BASE_DIR" || true
              exit 1
            fi

            # Clean stage and extract
            rm -rf "$STAGE_DIR"/* || true
            echo "Extracting to stage..."
            tar -xzf mydrreferral-api.tar.gz -C "$STAGE_DIR"

            # Determine API_DIR in stage
            if [ -f "$STAGE_DIR/MyDrReferral.Api.dll" ]; then
              NEW_API_DIR="$STAGE_DIR"
            elif [ -f "$STAGE_DIR/Api/MyDrReferral.Api.dll" ]; then
              NEW_API_DIR="$STAGE_DIR/Api"
            else
              echo "‚ùå Could not locate MyDrReferral.Api.dll in stage"
              find "$STAGE_DIR" -name "MyDrReferral.Api.dll" -type f | head -10
              exit 1
            fi
            echo "New build path: $NEW_API_DIR"

            # Install .NET if needed
            if ! command -v dotnet &> /dev/null; then
              echo "Installing .NET 8 runtime..."
              curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 8.0
              echo 'export DOTNET_ROOT=$HOME/.dotnet' >> ~/.bashrc
              echo 'export PATH=$PATH:$HOME/.dotnet' >> ~/.bashrc
              export DOTNET_ROOT=$HOME/.dotnet
              export PATH=$PATH:$HOME/.dotnet
            fi

            # Write/refresh systemd unit (rokda-hisab style: bind only to :5000)
            echo "Writing systemd unit $UNIT_FILE"
            sudo tee "$UNIT_FILE" > /dev/null <<EOF
            [Unit]
            Description=MyDrReferral API
            After=network.target

            [Service]
            WorkingDirectory=$CURR_DIR
            Environment=ASPNETCORE_ENVIRONMENT=Production
            Environment=ASPNETCORE_URLS=http://+:5000
            Environment=ConnectionStrings__DefaultConnection=Host=10.0.1.150;Port=5432;Database=postgres;Username=postgres;Password=MyDrReferral123;
            Environment=DOTNET_ROOT=/home/ec2-user/.dotnet
            ExecStart=/home/ec2-user/.dotnet/dotnet $CURR_DIR/MyDrReferral.Api.dll
            Restart=always
            RestartSec=5
            SyslogIdentifier=mydrreferral-api
            KillSignal=SIGINT
            Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false

            [Install]
            WantedBy=multi-user.target
            EOF

            # Atomic swap current -> new
            echo "Updating current build..."
            sudo rm -rf "$CURR_DIR" || true
            sudo mkdir -p "$CURR_DIR"
            sudo cp -a "$NEW_API_DIR"/. "$CURR_DIR"/
            echo "Current content:"
            ls -la "$CURR_DIR" | head -50

            # Ensure Nginx is stopped/disabled (no proxy; API binds to :80 directly)
            sudo systemctl stop nginx 2>/dev/null || true
            sudo systemctl disable nginx 2>/dev/null || true

            # Restart API via systemd
            echo "Reloading systemd and restarting service..."
            sudo systemctl daemon-reload
            sudo systemctl enable mydrreferral-api.service || true
            sudo systemctl restart mydrreferral-api.service

            # Wait and verify
            sleep 5
            sudo systemctl status mydrreferral-api.service --no-pager || true
            echo "Listening ports (expect :5000):"
            sudo ss -tlnp | grep -E ':5000' || true
            echo "Recent service logs:"
            sudo journalctl -u mydrreferral-api -n 120 --no-pager || true
            echo "Probing localhost endpoints..."
            curl -s http://localhost:5000/api/healthcheck/success || true
            echo
            curl -s http://localhost:5000/api/healthcheck/info || true
            echo
            curl -s http://localhost:5000/api/healthcheck/test2 || true

  # Health Check
  health-check:
    runs-on: ubuntu-latest
    needs: [deploy-api]
    timeout-minutes: 12
    steps:
      - name: Wait and test API
        run: |
          set -euo pipefail
          sleep 20
          echo "Testing API health..."
          for i in {1..5}; do
            if curl -sf --connect-timeout 2 --max-time 5 http://${{ secrets.EC2_HOST }}:5000/api/healthcheck/success; then
              echo "‚úÖ API is healthy on :5000"
              OK=1; break
            fi
            echo "Attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done
          if [ -z "$OK" ]; then
            echo "‚ùå API not reachable on :5000"
          fi
          
          echo ""
          echo "========================================="
          echo "Testing DateTime endpoint..."
          echo "========================================="
          
          echo "Trying GET first..."
          GET_RESPONSE=$(curl -s --connect-timeout 2 --max-time 5 http://${{ secrets.EC2_HOST }}:5000/api/healthcheck/test || echo "ERROR")
          echo "GET Response: $GET_RESPONSE"
          
          for i in {1..3}; do
            echo ""
            echo "Attempt $i: Calling test DateTime endpoint (POST)..."
            RESPONSE=$(curl -s --connect-timeout 2 --max-time 8 -w "\nHTTP_STATUS:%{http_code}" -X POST http://${{ secrets.EC2_HOST }}:5000/api/healthcheck/test 2>&1 || echo "HTTP_STATUS:000")
            HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS" | cut -d: -f2 || echo "000")
            BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS/d' | head -100)
            
            echo "Response Status: $HTTP_STATUS"
            echo "Response Body:"
            echo "$BODY"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ DateTime test PASSED"
              exit 0
            elif [ "$HTTP_STATUS" = "500" ]; then
              echo "‚ùå DateTime test FAILED with 500 error - this shows the DateTime issue!"
              echo "Full error details:"
              echo "$BODY"
              exit 1
            else
              if [ "$i" -lt 3 ]; then
                echo "Attempt $i failed (Status: $HTTP_STATUS), retrying in 3 seconds..."
                sleep 3
              fi
            fi
          done
          
          echo "‚ùå Could not reach endpoint (404). Checking if route exists..."
          curl -v --connect-timeout 2 --max-time 8 http://${{ secrets.EC2_HOST }}:5000/api/healthcheck/test 2>&1 | head -30 || true

      - name: Gather API diagnostics on EC2
        if: always()
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 4m
          command_timeout: 4m
          script: |
            echo "--- Listening ports ---"; sudo ss -tlnp | grep -E ':5000' || true
            echo "--- Service status ---"; sudo systemctl status mydrreferral-api --no-pager || true
            echo "--- Recent logs ---"; sudo journalctl -u mydrreferral-api -n 200 --no-pager || true
            echo "--- Dotnet version ---"; dotnet --info || true
            echo "--- Curl localhost probes ---"
            curl -s --connect-timeout 2 --max-time 5 http://localhost:5000/api/healthcheck/success || echo FAIL5000

      - name: Fail health-check if API unreachable
        if: always()
        run: |
          # Final quick probe: succeed if either endpoint responds
          if curl -sf --connect-timeout 2 --max-time 5 http://${{ secrets.EC2_HOST }}:5000/api/healthcheck/success; then
            echo "‚úÖ API became reachable"
            exit 0
          fi
          echo "‚ùå DateTime test failed after retries; API unreachable"
          exit 1

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-api, health-check]
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy-frontend.result }}" == "success" ] && [ "${{ needs.deploy-api.result }}" == "success" ] && [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
            echo "Frontend: http://${{ secrets.S3_BUCKET_NAME }}.s3-website.ap-south-1.amazonaws.com"
            echo "API: http://${{ secrets.EC2_HOST }}"
          else
            echo "‚ùå Deployment failed!"
            echo "Frontend: ${{ needs.deploy-frontend.result }}"
            echo "API: ${{ needs.deploy-api.result }}"
            echo "Health: ${{ needs.health-check.result }}"
            exit 1
          fi