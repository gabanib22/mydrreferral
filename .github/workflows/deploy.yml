name: Deploy MyDrReferral - Optimized

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-south-1

jobs:
  # Deploy Frontend to S3
  deploy-frontend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: Frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd Frontend
          npm ci

      - name: Build React app
        run: |
          cd Frontend
          npm run build
        env:
          NEXT_PUBLIC_API_URL: http://3.110.30.11

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          echo "Deploying frontend to S3 bucket: ${{ secrets.S3_BUCKET_NAME }}"
          aws s3 sync Frontend/out/ s3://${{ secrets.S3_BUCKET_NAME }} --delete
          aws s3 cp Frontend/out/index.html s3://${{ secrets.S3_BUCKET_NAME }}/index.html

  # Deploy API to EC2
  deploy-api:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: |
          cd Api
          dotnet restore --no-cache

      - name: Build API
        run: |
          cd Api
          dotnet build MyDrReferral.Api/MyDrReferral.Api.csproj --configuration Release --no-restore

      - name: Publish API
        run: |
          cd Api
          dotnet publish MyDrReferral.Api/MyDrReferral.Api.csproj --configuration Release --output ./publish --no-build

      - name: Create deployment package
        run: |
          cd Api
          tar -czf mydrreferral-api.tar.gz -C publish .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Copy API to EC2
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "Api/mydrreferral-api.tar.gz"
          target: "/var/www/mydrreferral/Api/"

      - name: Extract and start API
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 5m
          command_timeout: 5m
          script: |
            echo "üîß Starting API deployment..."
            cd /var/www/mydrreferral/Api/
            
            # Prepare fresh directory for atomic replace
            NEW_DIR="/var/www/mydrreferral/Api/new"
            rm -rf "$NEW_DIR" || true
            mkdir -p "$NEW_DIR"
            
            if [ -f mydrreferral-api.tar.gz ]; then
              echo "Extracting tar.gz into $NEW_DIR..."
              tar -xzf mydrreferral-api.tar.gz -C "$NEW_DIR"
              rm -f mydrreferral-api.tar.gz
              EXTRACTED=1
            else
              echo "‚ö†Ô∏è mydrreferral-api.tar.gz not found. Will try to use existing deployed DLL."
              EXTRACTED=0
            fi
            
            if [ "$EXTRACTED" = "1" ]; then
              echo "Contents of new build:"
              ls -lat "$NEW_DIR" | head -50
              
              # Determine API_DIR inside new
              if [ -f "$NEW_DIR/MyDrReferral.Api.dll" ]; then
                API_DIR="$NEW_DIR"
              elif [ -f "$NEW_DIR/Api/MyDrReferral.Api.dll" ]; then
                API_DIR="$NEW_DIR/Api"
              else
                echo "‚ùå Cannot find MyDrReferral.Api.dll in new build"
                find "$NEW_DIR" -name "MyDrReferral.Api.dll" -type f | head -10
                exit 1
              fi
              echo "Using API_DIR=$API_DIR (from extracted build)"
            else
              # Locate latest existing DLL under current path
              echo "Searching for existing MyDrReferral.Api.dll under /var/www/mydrreferral/Api..."
              DLL_PATH=$(find /var/www/mydrreferral/Api -name "MyDrReferral.Api.dll" -type f | head -1)
              if [ -z "$DLL_PATH" ]; then
                echo "‚ùå Could not locate MyDrReferral.Api.dll"
                find /var/www/mydrreferral/Api -maxdepth 3 -type f | head -50
                exit 1
              fi
              API_DIR=$(dirname "$DLL_PATH")
              echo "Using API_DIR=$API_DIR (existing deployment)"
            fi
            
            # Ensure .NET is available
            if ! command -v dotnet &> /dev/null; then
              echo "Installing .NET 8..."
              curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 8.0
              export DOTNET_ROOT=$HOME/.dotnet
              export PATH=$PATH:$HOME/.dotnet
            fi
            
            # Restart Nginx (ignore failures)
            sudo systemctl restart nginx || true
            
            # Stop service
            sudo systemctl stop mydrreferral-api.service || true
            sleep 1

            # Ensure port 5000 is free (try fuser, then ss, then netstat)
            echo "Ensuring port 5000 is free..."
            if command -v fuser >/dev/null 2>&1; then
              sudo fuser -k 5000/tcp || true
            else
              if command -v ss >/dev/null 2>&1; then
                PORT_PID=$(sudo ss -tulpn | awk '/:5000[ \t]/ {print $NF}' | sed 's/.*pid=\([0-9]*\).*/\1/' | head -1)
              else
                PORT_PID=$(sudo netstat -tulpn 2>/dev/null | awk '/:5000[ \t]/ {print $7}' | cut -d'/' -f1 | head -1)
              fi
              if [ -n "$PORT_PID" ]; then
                echo "Killing PID $PORT_PID on port 5000"
                sudo kill -9 "$PORT_PID" || true
              fi
            fi
            sleep 1
            
            if [ "$EXTRACTED" = "1" ]; then
              # Atomically replace current files
              echo "Replacing current API files..."
              rm -rf /var/www/mydrreferral/Api/current || true
              mv "$NEW_DIR" /var/www/mydrreferral/Api/current
              cd /var/www/mydrreferral/Api/current
            else
              cd "$API_DIR"
            fi
            
            export ASPNETCORE_ENVIRONMENT=Production
            export ASPNETCORE_URLS=http://+:5000
            export ConnectionStrings__DefaultConnection="Host=10.0.1.150;Port=5432;Database=postgres;Username=postgres;Password=MyDrReferral123;"
            
            LOG_FILE=/tmp/mydrreferral-api.log
            echo "Starting API from $(pwd) (DLL path: $API_DIR/MyDrReferral.Api.dll), logging to $LOG_FILE"
            nohup dotnet "$API_DIR/MyDrReferral.Api.dll" > "$LOG_FILE" 2>&1 &
            API_PID=$!
            echo "API started with PID: $API_PID"
            sleep 4
            
            echo "First 50 log lines (if any):"
            head -50 "$LOG_FILE" || true
            
            if ps -p $API_PID > /dev/null; then
              echo "‚úÖ API process is running"
              echo "Probing localhost endpoints..."
              echo "- /api/healthcheck/success:"
              curl -s http://localhost:5000/api/healthcheck/success || true
              echo "\n- /api/healthcheck/info:"
              curl -s http://localhost:5000/api/healthcheck/info || true
              echo "\n- /api/healthcheck/test2:"
              curl -s http://localhost:5000/api/healthcheck/test2 || true
            else
              echo "‚ùå API process died. Last 100 log lines:"
              tail -100 "$LOG_FILE" || true
              exit 1
            fi

  # Health Check
  health-check:
    runs-on: ubuntu-latest
    needs: [deploy-api]
    steps:
      - name: Wait and test API
        run: |
          sleep 15
          echo "Testing API health..."
          for i in {1..5}; do
            if curl -f http://${{ secrets.EC2_HOST }}/api/healthcheck/success; then
              echo "‚úÖ API is healthy"
              break
            fi
            echo "Attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done
          
          echo ""
          echo "========================================="
          echo "Testing DateTime endpoint..."
          echo "========================================="
          
          echo "Trying GET first..."
          GET_RESPONSE=$(curl -s http://${{ secrets.EC2_HOST }}/api/healthcheck/test || echo "ERROR")
          echo "GET Response: $GET_RESPONSE"
          
          for i in {1..3}; do
            echo ""
            echo "Attempt $i: Calling test DateTime endpoint (POST)..."
            RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST http://${{ secrets.EC2_HOST }}/api/healthcheck/test 2>&1 || echo "HTTP_STATUS:000")
            HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS" | cut -d: -f2 || echo "000")
            BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS/d' | head -100)
            
            echo "Response Status: $HTTP_STATUS"
            echo "Response Body:"
            echo "$BODY"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ DateTime test PASSED"
              exit 0
            elif [ "$HTTP_STATUS" = "500" ]; then
              echo "‚ùå DateTime test FAILED with 500 error - this shows the DateTime issue!"
              echo "Full error details:"
              echo "$BODY"
              exit 1
            else
              if [ "$i" -lt 3 ]; then
                echo "Attempt $i failed (Status: $HTTP_STATUS), retrying in 3 seconds..."
                sleep 3
              fi
            fi
          done
          
          echo "‚ùå Could not reach endpoint (404). Checking if route exists..."
          curl -v http://${{ secrets.EC2_HOST }}/api/healthcheck/test 2>&1 | head -30
          
          echo "‚ùå DateTime test failed after 3 attempts"
          exit 1

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-api, health-check]
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy-frontend.result }}" == "success" ] && [ "${{ needs.deploy-api.result }}" == "success" ] && [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
            echo "Frontend: http://${{ secrets.S3_BUCKET_NAME }}.s3-website.ap-south-1.amazonaws.com"
            echo "API: http://${{ secrets.EC2_HOST }}"
          else
            echo "‚ùå Deployment failed!"
            echo "Frontend: ${{ needs.deploy-frontend.result }}"
            echo "API: ${{ needs.deploy-api.result }}"
            echo "Health: ${{ needs.health-check.result }}"
            exit 1
          fi