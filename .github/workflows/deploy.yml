name: Deploy MyDrReferral - Optimized

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-south-1

jobs:
  # Deploy Frontend to S3
  deploy-frontend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: Frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd Frontend
          npm ci

      - name: Build React app
        run: |
          cd Frontend
          npm run build
        env:
          NEXT_PUBLIC_API_URL: http://3.110.30.11

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          echo "Deploying frontend to S3 bucket: ${{ secrets.S3_BUCKET_NAME }}"
          aws s3 sync Frontend/out/ s3://${{ secrets.S3_BUCKET_NAME }} --delete
          aws s3 cp Frontend/out/index.html s3://${{ secrets.S3_BUCKET_NAME }}/index.html

  # Deploy API to EC2
  deploy-api:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: |
          cd Api
          dotnet restore --no-cache

      - name: Build API
        run: |
          cd Api
          dotnet build MyDrReferral.Api/MyDrReferral.Api.csproj --configuration Release --no-restore

      - name: Publish API
        run: |
          cd Api
          dotnet publish MyDrReferral.Api/MyDrReferral.Api.csproj --configuration Release --output ./publish --no-build

      - name: Create deployment package
        run: |
          cd Api
          tar -czf mydrreferral-api.tar.gz -C publish .

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Copy API to EC2
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "Api/mydrreferral-api.tar.gz"
          target: "/var/www/mydrreferral/Api/"
          overwrite: true

      - name: Extract and start API
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 5m
          command_timeout: 5m
          script: |
            set -e
            echo "üîß Deploying API via systemd..."
            BASE_DIR=/var/www/mydrreferral/Api
            STAGE_DIR="$BASE_DIR/stage"
            CURR_DIR="$BASE_DIR/current"
            UNIT_FILE=/etc/systemd/system/mydrreferral-api.service
            LOG_FILE=/tmp/mydrreferral-api.log

            sudo mkdir -p "$BASE_DIR" "$STAGE_DIR"
            cd "$BASE_DIR"

            # Ensure tar is present (SCP step sets overwrite: true)
            if [ ! -f mydrreferral-api.tar.gz ]; then
              echo "‚ùå Archive missing: $BASE_DIR/mydrreferral-api.tar.gz"
              ls -la "$BASE_DIR" || true
              exit 1
            fi

            # Prepare stage and extract
            rm -rf "$STAGE_DIR"/* || true
            echo "Extracting to stage..."
            tar -xzf mydrreferral-api.tar.gz -C "$STAGE_DIR"

            # Determine API_DIR in stage
            if [ -f "$STAGE_DIR/MyDrReferral.Api.dll" ]; then
              NEW_API_DIR="$STAGE_DIR"
            elif [ -f "$STAGE_DIR/Api/MyDrReferral.Api.dll" ]; then
              NEW_API_DIR="$STAGE_DIR/Api"
            else
              echo "‚ùå Could not locate MyDrReferral.Api.dll in stage"
              find "$STAGE_DIR" -name "MyDrReferral.Api.dll" -type f | head -10
              exit 1
            fi
            echo "New build path: $NEW_API_DIR"

            # Install .NET if needed
            if ! command -v dotnet &> /dev/null; then
              echo "Installing .NET 8 runtime..."
              curl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 8.0
              echo 'export DOTNET_ROOT=$HOME/.dotnet' >> ~/.bashrc
              echo 'export PATH=$PATH:$HOME/.dotnet' >> ~/.bashrc
              export DOTNET_ROOT=$HOME/.dotnet
              export PATH=$PATH:$HOME/.dotnet
            fi

            # Write/refresh systemd unit (mirrors rokda-hisab pattern)
            echo "Writing systemd unit $UNIT_FILE"
            sudo tee "$UNIT_FILE" > /dev/null <<EOF
            [Unit]
            Description=MyDrReferral API
            After=network.target

            [Service]
            WorkingDirectory=$CURR_DIR
            ExecStart=/bin/bash -lc 'export ASPNETCORE_ENVIRONMENT=Production ASPNETCORE_URLS=http://+:5000 ConnectionStrings__DefaultConnection="Host=10.0.1.150;Port=5432;Database=postgres;Username=postgres;Password=MyDrReferral123;" && exec dotnet $CURR_DIR/MyDrReferral.Api.dll'
            Restart=always
            RestartSec=5
            SyslogIdentifier=mydrreferral-api
            KillSignal=SIGINT
            Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false

            [Install]
            WantedBy=multi-user.target
            EOF

            # Atomic swap current -> new
            echo "Updating current build..."
            sudo rm -rf "$CURR_DIR" || true
            sudo mkdir -p "$CURR_DIR"
            sudo cp -a "$NEW_API_DIR"/. "$CURR_DIR"/
            echo "Current content:"
            ls -la "$CURR_DIR" | head -50

            # Nginx ensure and restart
            if ! command -v nginx &> /dev/null; then
              echo "Installing Nginx..."
              sudo amazon-linux-extras install -y nginx1 >/dev/null 2>&1 || true
              sudo systemctl enable nginx || true
            fi
            sudo tee /etc/nginx/conf.d/mydrreferral.conf > /dev/null <<NGINX
            server {
                listen 80;
                server_name _;
                location / {
                    proxy_pass http://localhost:5000;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade $http_upgrade;
                    proxy_set_header Connection keep-alive;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
                    proxy_cache_bypass $http_upgrade;
                }
            }
            NGINX
            sudo systemctl restart nginx || true

            # Restart API via systemd
            echo "Reloading systemd and restarting service..."
            sudo systemctl daemon-reload
            sudo systemctl enable mydrreferral-api.service || true
            sudo systemctl restart mydrreferral-api.service

            # Wait and verify
            sleep 5
            sudo systemctl status mydrreferral-api.service --no-pager || true
            echo "Probing localhost endpoints..."
            curl -s http://localhost:5000/api/healthcheck/success || true
            echo
            curl -s http://localhost:5000/api/healthcheck/info || true
            echo
            curl -s http://localhost:5000/api/healthcheck/test2 || true

  # Health Check
  health-check:
    runs-on: ubuntu-latest
    needs: [deploy-api]
    steps:
      - name: Wait and test API
        run: |
          sleep 15
          echo "Testing API health..."
          for i in {1..5}; do
            if curl -f http://${{ secrets.EC2_HOST }}/api/healthcheck/success; then
              echo "‚úÖ API is healthy"
              break
            fi
            echo "Attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done
          
          echo ""
          echo "========================================="
          echo "Testing DateTime endpoint..."
          echo "========================================="
          
          echo "Trying GET first..."
          GET_RESPONSE=$(curl -s http://${{ secrets.EC2_HOST }}/api/healthcheck/test || echo "ERROR")
          echo "GET Response: $GET_RESPONSE"
          
          for i in {1..3}; do
            echo ""
            echo "Attempt $i: Calling test DateTime endpoint (POST)..."
            RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST http://${{ secrets.EC2_HOST }}/api/healthcheck/test 2>&1 || echo "HTTP_STATUS:000")
            HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS" | cut -d: -f2 || echo "000")
            BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS/d' | head -100)
            
            echo "Response Status: $HTTP_STATUS"
            echo "Response Body:"
            echo "$BODY"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ DateTime test PASSED"
              exit 0
            elif [ "$HTTP_STATUS" = "500" ]; then
              echo "‚ùå DateTime test FAILED with 500 error - this shows the DateTime issue!"
              echo "Full error details:"
              echo "$BODY"
              exit 1
            else
              if [ "$i" -lt 3 ]; then
                echo "Attempt $i failed (Status: $HTTP_STATUS), retrying in 3 seconds..."
                sleep 3
              fi
            fi
          done
          
          echo "‚ùå Could not reach endpoint (404). Checking if route exists..."
          curl -v http://${{ secrets.EC2_HOST }}/api/healthcheck/test 2>&1 | head -30
          
          echo "‚ùå DateTime test failed after 3 attempts"
          exit 1

  # Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-api, health-check]
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy-frontend.result }}" == "success" ] && [ "${{ needs.deploy-api.result }}" == "success" ] && [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
            echo "Frontend: http://${{ secrets.S3_BUCKET_NAME }}.s3-website.ap-south-1.amazonaws.com"
            echo "API: http://${{ secrets.EC2_HOST }}"
          else
            echo "‚ùå Deployment failed!"
            echo "Frontend: ${{ needs.deploy-frontend.result }}"
            echo "API: ${{ needs.deploy-api.result }}"
            echo "Health: ${{ needs.health-check.result }}"
            exit 1
          fi